$date
	Fri Jun 30 10:31:42 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Mux2to1 $end
$var wire 32 ! in0 [31:0] $end
$var wire 32 " in1 [31:0] $end
$var wire 1 # sel $end
$var reg 32 $ out [31:0] $end
$upscope $end
$scope module Mux4to1 $end
$var wire 32 % in0 [31:0] $end
$var wire 32 & in1 [31:0] $end
$var wire 32 ' in2 [31:0] $end
$var wire 32 ( in3 [31:0] $end
$var wire 2 ) sel [1:0] $end
$var reg 32 * out [31:0] $end
$upscope $end
$scope module TB $end
$var wire 32 + PC_Next [31:0] $end
$var wire 32 , PC [31:0] $end
$var wire 32 - Instruction [31:0] $end
$var reg 32 . Address [31:0] $end
$var reg 2 / PC_Src [1:0] $end
$var reg 32 0 branchAddress [31:0] $end
$var reg 1 1 clk $end
$var reg 32 2 jumpAddress [31:0] $end
$var reg 1 3 rst $end
$scope module test $end
$var wire 2 4 PC_Src [1:0] $end
$var wire 32 5 branchAddress [31:0] $end
$var wire 1 1 clk $end
$var wire 32 6 jumpAddress [31:0] $end
$var wire 1 3 rst $end
$var wire 32 7 PC_Next [31:0] $end
$var wire 32 8 PC [31:0] $end
$var wire 32 9 Instruction [31:0] $end
$var wire 32 : Address [31:0] $end
$var reg 32 ; Inst [31:0] $end
$var reg 32 < NPC [31:0] $end
$scope module Pcsrc_MUX $end
$var wire 32 = in1 [31:0] $end
$var wire 32 > in2 [31:0] $end
$var wire 2 ? sel [1:0] $end
$var wire 32 @ in0 [31:0] $end
$var reg 32 A out [31:0] $end
$upscope $end
$scope module inst $end
$var wire 1 3 rst $end
$var wire 32 B instruction [31:0] $end
$var wire 32 C address [31:0] $end
$upscope $end
$scope module pc4 $end
$var wire 32 D PC_Next [31:0] $end
$var wire 32 E PC [31:0] $end
$upscope $end
$scope module pc_mod $end
$var wire 32 F address [31:0] $end
$var wire 1 1 clk $end
$var wire 1 3 rst $end
$var reg 32 G PC [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx G
bx F
bx E
bx D
bx C
b0 B
bx A
bx @
bx ?
bx >
bx =
b0 <
b0 ;
bx :
b0 9
bx 8
bx 7
bx 6
bx 5
bx 4
03
bx 2
01
bx 0
bx /
bx .
b0 -
bx ,
bx +
bx *
bz )
bz (
bz '
bz &
bz %
bx $
z#
bz "
bz !
$end
#50
b100 +
b100 7
b100 @
b100 D
b0 ,
b0 8
b0 C
b0 E
b0 G
11
#100
01
#150
11
#200
b1001000110100010101100111 -
b1001000110100010101100111 9
b1001000110100010101100111 B
b100 :
b100 A
b100 F
b0 .
b0 /
b0 4
b0 ?
13
01
#250
b10001001101010111100110111101111 -
b10001001101010111100110111101111 9
b10001001101010111100110111101111 B
b1000 :
b1000 A
b1000 F
b1000 +
b1000 7
b1000 @
b1000 D
b100 ,
b100 8
b100 C
b100 E
b100 G
b1001000110100010101100111 ;
b100 <
11
#300
01
#350
bx -
bx 9
bx B
b1100 :
b1100 A
b1100 F
b1100 +
b1100 7
b1100 @
b1100 D
b1000 ,
b1000 8
b1000 C
b1000 E
b1000 G
b10001001101010111100110111101111 ;
b1000 <
11
#400
01
#450
b10000 :
b10000 A
b10000 F
b10000 +
b10000 7
b10000 @
b10000 D
b1100 ,
b1100 8
b1100 C
b1100 E
b1100 G
bx ;
b1100 <
11
#500
01
#550
b10100 :
b10100 A
b10100 F
b10100 +
b10100 7
b10100 @
b10100 D
b10000 ,
b10000 8
b10000 C
b10000 E
b10000 G
b10000 <
11
#600
01
#650
b11000 :
b11000 A
b11000 F
b11000 +
b11000 7
b11000 @
b11000 D
b10100 ,
b10100 8
b10100 C
b10100 E
b10100 G
b10100 <
11
#700
01
